export const exampleUseCases = [
  {
    challenge: "Cut the noise, while remaining transparent",
    solution: "Each roles submits proposals, votes and executes within their role defined group, but open for all to see.",
    examples: ["example 1", "example 2", "example 3"]
  },
  {
    challenge: "Avoid disengagement by designating roles to diverse groups",
    solution: "Create roles for builders, community leaders, token holders and any other stake holder. Giving different groups actual influence in community governance will boost participation.",
    examples: ["example 1", "example 2", "example 3"]
  },
  {
    challenge: "Avoid centralisation by balancing powers",
    solution: "Roles can balance each other powers through governance chains. Allow actions to only be executed if two different roles voted it through, for example, or if one role did not oppose the action.",
    examples: ["example 1", "example 2", "example 3"]
  },
  {
    challenge: "Increase security by checking executive actions",
    solution: "Only allow tasks to be executed if certain conditions have been met. For example, if other roles have (not) passed like-for-like proposals.",
    examples: ["example 1", "example 2", "example 3"]
  }, 
  {
    challenge: "Increase efficiency by delegating tasks", 
    solution: "Define tasks in external programmable contracts, called laws, and assign them to specific roles.",
    examples: ["example 1", "example 2", "example 3"] 
  }, 
  {
    challenge: "Seamlessly adapt to changing circumstances",
    solution: "The protocol consists of laws that define roles and their powers. Laws can be adopted and revoked to adapt to changing circumstances, but only through existing governance mechanisms.",
    examples: ["example 1", "example 2", "example 3"] 
}, 
]